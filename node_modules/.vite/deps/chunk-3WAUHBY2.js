// node_modules/@lemoncode/fonk/dist/@lemoncode/fonk.esm.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var FUNC_ERROR_TEXT$1 = "Expected a function";
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var INFINITY$1 = 1 / 0;
var MAX_SAFE_INTEGER = 9007199254740991;
var funcTag$1 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var symbolTag$1 = "[object Symbol]";
var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp$1 = /^\w*$/;
var reLeadingDot$1 = /^\./;
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar$1 = /\\(\\)?/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var freeGlobal$1 = _typeof(commonjsGlobal) == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$1 = (typeof self === "undefined" ? "undefined" : _typeof(self)) == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal$1 || freeSelf$1 || Function("return this")();
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject$1(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e) {
    }
  }
  return result;
}
var arrayProto$1 = Array.prototype;
var funcProto$1 = Function.prototype;
var objectProto$1 = Object.prototype;
var coreJsData$1 = root$1["__core-js_shared__"];
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(
    coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || ""
  );
  return uid ? "Symbol(src)_1." + uid : "";
}();
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
var objectToString$1 = objectProto$1.toString;
var reIsNative$1 = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar$1, "\\$&").replace(
    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
    "$1.*?"
  ) + "$"
);
var _Symbol$1 = root$1.Symbol;
var splice$1 = arrayProto$1.splice;
var Map$1 = getNative$1(root$1, "Map");
var nativeCreate$1 = getNative$1(Object, "create");
var symbolProto$1 = _Symbol$1 ? _Symbol$1.prototype : void 0;
var symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : void 0;
function Hash$1(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function hashClear$1() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
}
function hashDelete$1(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
}
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
}
function hashSet$1(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
Hash$1.prototype.clear = hashClear$1;
Hash$1.prototype["delete"] = hashDelete$1;
Hash$1.prototype.get = hashGet$1;
Hash$1.prototype.has = hashHas$1;
Hash$1.prototype.set = hashSet$1;
function ListCache$1(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear$1() {
  this.__data__ = [];
}
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index2, 1);
  }
  return true;
}
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
ListCache$1.prototype.clear = listCacheClear$1;
ListCache$1.prototype["delete"] = listCacheDelete$1;
ListCache$1.prototype.get = listCacheGet$1;
ListCache$1.prototype.has = listCacheHas$1;
ListCache$1.prototype.set = listCacheSet$1;
function MapCache$1(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear$1() {
  this.__data__ = {
    hash: new Hash$1(),
    map: new (Map$1 || ListCache$1)(),
    string: new Hash$1()
  };
}
function mapCacheDelete$1(key) {
  return getMapData$1(this, key)["delete"](key);
}
function mapCacheGet$1(key) {
  return getMapData$1(this, key).get(key);
}
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
function mapCacheSet$1(key, value) {
  getMapData$1(this, key).set(key, value);
  return this;
}
MapCache$1.prototype.clear = mapCacheClear$1;
MapCache$1.prototype["delete"] = mapCacheDelete$1;
MapCache$1.prototype.get = mapCacheGet$1;
MapCache$1.prototype.has = mapCacheHas$1;
MapCache$1.prototype.set = mapCacheSet$1;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$1.call(object, key) && eq$1(objValue, value)) || value === void 0 && !(key in object)) {
    object[key] = value;
  }
}
function assocIndexOf$1(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq$1(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseIsNative$1(value) {
  if (!isObject$1(value) || isMasked$1(value)) {
    return false;
  }
  var pattern2 = isFunction$2(value) || isHostObject$1(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern2.test(toSource$1(value));
}
function baseSet(object, path, value, customizer) {
  if (!isObject$1(object)) {
    return object;
  }
  path = isKey$1(path, object) ? [path] : castPath$1(path);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key = toKey$1(path[index2]), newValue = value;
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol$1(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function castPath$1(value) {
  return isArray$1(value) ? value : stringToPath$1(value);
}
function getMapData$1(map, key) {
  var data = map.__data__;
  return isKeyable$1(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative$1(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative$1(value) ? value : void 0;
}
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
function isKey$1(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = _typeof(value);
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
}
function isKeyable$1(value) {
  var type = _typeof(value);
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var stringToPath$1 = memoize$1(function(string) {
  string = toString$1(string);
  var result = [];
  if (reLeadingDot$1.test(string)) {
    result.push("");
  }
  string.replace(rePropName$1, function(match, number, quote, string2) {
    result.push(quote ? string2.replace(reEscapeChar$1, "$1") : number || match);
  });
  return result;
});
function toKey$1(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function memoized2() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized2.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized2.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache$1)();
  return memoized;
}
memoize$1.Cache = MapCache$1;
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}
var isArray$1 = Array.isArray;
function isFunction$2(value) {
  var tag = isObject$1(value) ? objectToString$1.call(value) : "";
  return tag == funcTag$1 || tag == genTag$1;
}
function isObject$1(value) {
  var type = _typeof(value);
  return !!value && (type == "object" || type == "function");
}
function isObjectLike$1(value) {
  return !!value && _typeof(value) == "object";
}
function isSymbol$1(value) {
  return _typeof(value) == "symbol" || isObjectLike$1(value) && objectToString$1.call(value) == symbolTag$1;
}
function toString$1(value) {
  return value == null ? "" : baseToString$1(value);
}
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}
var set_1 = set;
var safeArrayLength = function safeArrayLength2(collection) {
  return Array.isArray(collection) ? collection.length : 0;
};
var arrayContainsEntries = function arrayContainsEntries2(collection) {
  return safeArrayLength(collection) > 0;
};
var isFunction$1 = function isFunction(v) {
  return typeof v === "function";
};
var isUndefinedOrNull = function isUndefinedOrNull2(v) {
  return v === void 0 || v === null;
};
var isPromise = function isPromise2(value) {
  return value instanceof Promise;
};
var safeObjectKeys = function safeObjectKeys2(value) {
  return Boolean(value) ? Object.keys(value) : [];
};
var reduceAsync = function reduceAsync2(collection, callback, defaultResult) {
  return Array.isArray(collection) ? collection.reduce(function(promise, item, index2) {
    return promise.then(function(result) {
      return callback(result, item, index2);
    });
  }, Promise.resolve(defaultResult)) : Promise.resolve(defaultResult);
};
var isFieldIdInSchema = function isFieldIdInSchema2(fieldId, schema) {
  return !isUndefinedOrNull(schema) && !isUndefinedOrNull(schema[fieldId]);
};
var hasFieldIdArrayValidator = function hasFieldIdArrayValidator2(fieldId, schema) {
  return /\[.*\]/.test(fieldId) && !isFieldIdInSchema(fieldId, schema);
};
var formatFieldForArrayField = function formatFieldForArrayField2(fieldId, value) {
  var formattedValue = set_1({}, fieldId, value);
  var keys = Boolean(fieldId) ? Object.keys(formattedValue) : [""];
  var id = Array.isArray(keys) && keys.length > 0 ? keys[0] : "";
  return {
    id,
    value: Array.isArray(formattedValue[id]) ? _toConsumableArray(
      formattedValue[id]
    ) : formattedValue[id]
  };
};
var FUNC_ERROR_TEXT = "Expected a function";
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var INFINITY = 1 / 0;
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var symbolTag = "[object Symbol]";
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
var reLeadingDot = /^\./;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var freeGlobal = _typeof(commonjsGlobal) == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e) {
    }
  }
  return result;
}
var arrayProto = Array.prototype;
var funcProto = Function.prototype;
var objectProto = Object.prototype;
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(
    coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || ""
  );
  return uid ? "Symbol(src)_1." + uid : "";
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(
    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
    "$1.*?"
  ) + "$"
);
var _Symbol = root.Symbol;
var splice = arrayProto.splice;
var Map = getNative(root, "Map");
var nativeCreate = getNative(Object, "create");
var symbolProto = _Symbol ? _Symbol.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function Hash(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : void 0;
}
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
}
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear() {
  this.__data__ = {
    hash: new Hash(),
    map: new (Map || ListCache)(),
    string: new Hash()
  };
}
function mapCacheDelete(key) {
  return getMapData(this, key)["delete"](key);
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function assocIndexOf(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern2 = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern2.test(toSource(value));
}
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = _typeof(value);
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isKeyable(value) {
  var type = _typeof(value);
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var stringToPath = memoize(function(string) {
  string = toString(string);
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, string2) {
    result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
function memoize(func, resolver) {
  if (typeof func != "function" || resolver && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function memoized2() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized2.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized2.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var isArray = Array.isArray;
function isFunction2(value) {
  var tag = isObject(value) ? objectToString.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isObject(value) {
  var type = _typeof(value);
  return !!value && (type == "object" || type == "function");
}
function isObjectLike(value) {
  return !!value && _typeof(value) == "object";
}
function isSymbol(value) {
  return _typeof(value) == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get;
var createDefaultValidationResult = function createDefaultValidationResult2() {
  return {
    type: "",
    succeeded: true,
    message: ""
  };
};
var createDefaultInternalValidationResult = function createDefaultInternalValidationResult2() {
  return {
    key: "",
    type: "",
    succeeded: true,
    message: ""
  };
};
var createDefaultRecordValidationResult = function createDefaultRecordValidationResult2() {
  return {
    succeeded: true,
    recordErrors: {}
  };
};
var createDefaultFormValidationResult = function createDefaultFormValidationResult2() {
  return {
    succeeded: true,
    fieldErrors: {},
    recordErrors: {}
  };
};
var createDefaultInternalFormValidationResult = function createDefaultInternalFormValidationResult2() {
  return {
    succeeded: true,
    fieldErrors: {},
    recordErrors: {}
  };
};
var convertFieldValidationToAsyncIfNeeded = function convertFieldValidationToAsyncIfNeeded2(validation) {
  return function(fieldValidatorArgs) {
    var result = validation ? validation(fieldValidatorArgs) : createDefaultValidationResult();
    return isPromise(result) ? result : Promise.resolve(result);
  };
};
var convertRecordValidationToAsyncIfNeeded = function convertRecordValidationToAsyncIfNeeded2(validation) {
  return function(recordValidatorArgs) {
    var result = validation ? validation(recordValidatorArgs) : createDefaultValidationResult();
    return isPromise(result) ? result : Promise.resolve(result);
  };
};
var mapToInternalFieldValidation = function mapToInternalFieldValidation2(fieldValidation) {
  return isFunction$1(fieldValidation) ? {
    validator: convertFieldValidationToAsyncIfNeeded(fieldValidation),
    message: void 0,
    customArgs: void 0
  } : {
    validator: convertFieldValidationToAsyncIfNeeded(isFunction$1(fieldValidation.validator) ? fieldValidation.validator : fieldValidation.validator.validator),
    customArgs: fieldValidation.customArgs,
    message: fieldValidation.message
  };
};
var mapToInternalValidationCollection$1 = function mapToInternalValidationCollection(fieldValidations) {
  return Array.isArray(fieldValidations) ? fieldValidations.map(mapToInternalFieldValidation) : [];
};
var buildIntertalSchema$1 = function buildIntertalSchema(internalSchema) {
  return internalSchema.reduce(function(internalFieldValidations, _ref) {
    var _ref2 = _slicedToArray(_ref, 2), fieldId = _ref2[0], fieldValidations = _ref2[1];
    internalFieldValidations[fieldId] = fieldValidations;
    return internalFieldValidations;
  }, {});
};
var mapToInternalFieldValidationSchema = function mapToInternalFieldValidationSchema2(fieldValidationSchema) {
  var validationSchema = fieldValidationSchema instanceof Object ? fieldValidationSchema : {};
  var internalFieldValidations = Object.entries(validationSchema).map(function(_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), fielId = _ref4[0], fieldValidations = _ref4[1];
    return [
      fielId,
      mapToInternalValidationCollection$1(fieldValidations)
    ];
  });
  return buildIntertalSchema$1(internalFieldValidations);
};
var mapToInternalRecordValidation = function mapToInternalRecordValidation2(recordValidation) {
  return isFunction$1(recordValidation) ? {
    validator: convertRecordValidationToAsyncIfNeeded(recordValidation),
    message: void 0
  } : {
    validator: convertRecordValidationToAsyncIfNeeded(isFunction$1(recordValidation.validator) ? recordValidation.validator : recordValidation.validator.validator),
    message: recordValidation.message
  };
};
var mapToInternalValidationCollection2 = function mapToInternalValidationCollection3(recordValidations) {
  return Array.isArray(recordValidations) ? recordValidations.map(mapToInternalRecordValidation) : [];
};
var buildIntertalSchema2 = function buildIntertalSchema3(internalSchema) {
  return internalSchema.reduce(function(internalRecordValidations, _ref) {
    var _ref2 = _slicedToArray(_ref, 2), recordId = _ref2[0], recordValidations = _ref2[1];
    internalRecordValidations[recordId] = recordValidations;
    return internalRecordValidations;
  }, {});
};
var mapToInternalRecordValidationSchema = function mapToInternalRecordValidationSchema2(recordValidationSchema) {
  var validationSchema = recordValidationSchema instanceof Object ? recordValidationSchema : {};
  var internalRecordValidations = Object.entries(validationSchema).map(function(_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), fielId = _ref4[0], recordValidations = _ref4[1];
    return [
      fielId,
      mapToInternalValidationCollection2(recordValidations)
    ];
  });
  return buildIntertalSchema2(internalRecordValidations);
};
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var renameFieldNameKeys = function renameFieldNameKeys2(internalValidationResult, fieldKey, fieldErrors, index2) {
  var fieldNames = Object.keys(fieldErrors);
  return fieldNames.reduce(function(result, fieldName) {
    return Object.assign(Object.assign({}, result), _defineProperty({}, "".concat(fieldKey, "[").concat(index2, "].").concat(fieldName), fieldErrors[fieldName]));
  }, {});
};
var mapArrayErrorListToValidationResult = function mapArrayErrorListToValidationResult2(internalValidationResult, fieldKey) {
  return internalValidationResult.arrayErrors.reduce(function(validationResult, fieldErrors, index2) {
    return Object.assign(Object.assign({}, validationResult), renameFieldNameKeys(internalValidationResult, fieldKey, fieldErrors, index2));
  }, {});
};
var mapInternalValidationResultToValidationResult = function mapInternalValidationResultToValidationResult2(internalValidationResult) {
  return Boolean(internalValidationResult.arrayErrors) ? mapArrayErrorListToValidationResult(internalValidationResult, internalValidationResult.key) : {
    type: internalValidationResult.type,
    message: internalValidationResult.message,
    succeeded: internalValidationResult.succeeded
  };
};
var mapInternalFieldErrorsToFieldErrors = function mapInternalFieldErrorsToFieldErrors2(internalFieldErrors) {
  return Object.keys(internalFieldErrors).reduce(function(fieldErrors, field) {
    var validationResult = internalFieldErrors[field];
    var fieldValidationResult = Boolean(validationResult.arrayErrors) ? mapArrayErrorListToValidationResult(validationResult, field) : _defineProperty(
      {},
      field,
      validationResult
    );
    return Object.assign(Object.assign({}, fieldErrors), fieldValidationResult);
  }, {});
};
var mapInternalFormValidationResultToFormValidationResult = function mapInternalFormValidationResultToFormValidationResult2(internalFormValidationResult) {
  return {
    succeeded: internalFormValidationResult.succeeded,
    recordErrors: internalFormValidationResult.recordErrors,
    fieldErrors: mapInternalFieldErrorsToFieldErrors(internalFormValidationResult.fieldErrors)
  };
};
var fireAllFieldsValidations = function fireAllFieldsValidations2(fieldIds, values, schema, validateField3) {
  return fieldIds.map(function(fieldId) {
    return validateField3(fieldId, get_1(values, fieldId, void 0), values, schema);
  });
};
var fireAllRecordsValidations = function fireAllRecordsValidations2(recordIds, values, schema, validateRecord3) {
  return recordIds.map(function(recordId) {
    return validateRecord3(recordId, values, schema);
  });
};
var checkValidationResult$1 = function checkValidationResult(validationResult) {
  var result = validationResult;
  if (!validationResult || isUndefinedOrNull(validationResult.succeeded)) {
    console.error("form-validators: One of the record validator is returning a non expected value.");
    result = createDefaultInternalValidationResult();
  }
  return result;
};
var fireValidation$1 = function fireValidation(values, internalRecordValidation) {
  return internalRecordValidation.validator({
    values,
    message: internalRecordValidation.message
  }).then(checkValidationResult$1);
};
var iterateValidationsUntilFailOrAllSucceeded$1 = function iterateValidationsUntilFailOrAllSucceeded(values, internalRecordValidations) {
  return internalRecordValidations.reduce(
    function(result, next) {
      return result.then(function(validationResult) {
        return validationResult.succeeded ? fireValidation$1(values, next) : validationResult;
      });
    },
    fireValidation$1(values, internalRecordValidations[0])
    // Initial reduce value
  );
};
var fireSingleRecordValidations = function fireSingleRecordValidations2(values, internalRecordValidations) {
  return arrayContainsEntries(internalRecordValidations) ? iterateValidationsUntilFailOrAllSucceeded$1(values, internalRecordValidations) : Promise.resolve(createDefaultInternalValidationResult());
};
var checkValidationResult2 = function checkValidationResult3(validationResult) {
  var result = validationResult;
  if (!validationResult || isUndefinedOrNull(validationResult.succeeded)) {
    console.error("form-validators: One of the field validator is returning a non expected value.");
    result = createDefaultInternalValidationResult();
  }
  return result;
};
var fireValidation2 = function fireValidation3(value, values, internalFieldValidation) {
  return internalFieldValidation.validator({
    value,
    values,
    customArgs: internalFieldValidation.customArgs,
    message: internalFieldValidation.message
  }).then(checkValidationResult2);
};
var iterateValidationsUntilFailOrAllSucceeded2 = function iterateValidationsUntilFailOrAllSucceeded3(value, values, internalFieldValidations) {
  return internalFieldValidations.reduce(
    function(result, next) {
      return result.then(function(validationResult) {
        return validationResult.succeeded ? fireValidation2(value, values, next) : validationResult;
      });
    },
    fireValidation2(value, values, internalFieldValidations[0])
    // Initial reduce value
  );
};
var fireSingleFieldValidations = function fireSingleFieldValidations2(value, values, internalFieldValidations) {
  return arrayContainsEntries(internalFieldValidations) ? iterateValidationsUntilFailOrAllSucceeded2(value, values, internalFieldValidations) : Promise.resolve(createDefaultInternalValidationResult());
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var didAllValidationsSucceeded = function didAllValidationsSucceeded2(validationResults) {
  return validationResults.every(function(fvr) {
    return fvr.succeeded;
  });
};
var extractErrors = function extractErrors2(validationResults) {
  return validationResults.reduce(function(errors, _a) {
    var key = _a.key, validationResult = __rest(_a, ["key"]);
    errors[key] = Object.assign({}, validationResult);
    return errors;
  }, {});
};
var buildRecordValidationResult = function buildRecordValidationResult2(validationResults) {
  var recordValidationResult = createDefaultRecordValidationResult();
  if (arrayContainsEntries(validationResults)) {
    recordValidationResult.succeeded = didAllValidationsSucceeded(validationResults);
    recordValidationResult.recordErrors = extractErrors(validationResults);
  }
  return recordValidationResult;
};
var buildFormValidationResult = function buildFormValidationResult2(fieldValidationResults, recordValidationResults) {
  var formValidationResult = createDefaultInternalFormValidationResult();
  if (arrayContainsEntries(fieldValidationResults)) {
    formValidationResult.succeeded = didAllValidationsSucceeded(fieldValidationResults);
    formValidationResult.fieldErrors = extractErrors(fieldValidationResults);
  }
  if (arrayContainsEntries(recordValidationResults)) {
    var recordResults = buildRecordValidationResult(recordValidationResults);
    formValidationResult.succeeded = formValidationResult.succeeded && recordResults.succeeded;
    formValidationResult.recordErrors = recordResults.recordErrors;
  }
  return formValidationResult;
};
var validateField = function validateField2(fieldId, value, values, schema) {
  return !isFieldIdInSchema(fieldId, schema) ? Promise.resolve(createDefaultInternalValidationResult()) : fireSingleFieldValidations(value, values, schema[fieldId]).then(function(validationResult) {
    validationResult.key = fieldId;
    return validationResult;
  })["catch"](
    function(error) {
      var message = "Validation Exception, field: ".concat(fieldId);
      console.error(message);
      throw error;
    }
  );
};
var validateSingleRecord = function validateSingleRecord2(recordId, values, schema) {
  return !isFieldIdInSchema(recordId, schema) ? Promise.resolve(createDefaultInternalValidationResult()) : fireSingleRecordValidations(values, schema[recordId]).then(function(validationResult) {
    validationResult.key = recordId;
    return validationResult;
  })["catch"](
    function(error) {
      var message = "Validation Exception, record: ".concat(recordId);
      console.error(message);
      throw error;
    }
  );
};
var validateRecord = function validateRecord2(values, schema) {
  var promiseValidationResults = fireAllRecordsValidations(safeObjectKeys(schema), values, schema, validateSingleRecord);
  return Promise.all(promiseValidationResults).then(function(validationResults) {
    return buildRecordValidationResult(validationResults);
  })["catch"](
    function(error) {
      var message = "Uncontrolled error validating records";
      console.error(message);
      throw error;
    }
  );
};
var validateForm = function validateForm2(values, fieldSchema, recordSchema) {
  var promiseFieldValidationResults = fireAllFieldsValidations(safeObjectKeys(fieldSchema), values, fieldSchema, validateField);
  var promiseRecordValidationResults = fireAllRecordsValidations(safeObjectKeys(recordSchema), values, recordSchema, validateSingleRecord);
  return Promise.all(promiseFieldValidationResults).then(function(fieldValidationResults) {
    return Promise.all(promiseRecordValidationResults).then(function(recordValidationResults) {
      return [
        fieldValidationResults,
        recordValidationResults
      ];
    });
  }).then(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), fieldValidationResults = _ref2[0], recordValidationResults = _ref2[1];
    return buildFormValidationResult(fieldValidationResults, recordValidationResults);
  })["catch"](
    function(error) {
      var message = "Uncontrolled error validating form";
      console.error(message);
      throw error;
    }
  );
};
var FormValidation = function FormValidation2(validationSchema) {
  var _this = this;
  _classCallCheck(this, FormValidation2);
  this.fieldSchema = {};
  this.recordSchema = {};
  this.setupValidationSchema = function(validationSchema2) {
    if (validationSchema2 && _typeof(validationSchema2) === "object") {
      var record = validationSchema2.record, field = validationSchema2.field;
      if (field && _typeof(field) === "object") {
        _this.fieldSchema = mapToInternalFieldValidationSchema(validationSchema2.field);
      }
      if (record && _typeof(record) === "object") {
        _this.recordSchema = mapToInternalRecordValidationSchema(validationSchema2.record);
      }
    } else {
      console.error("ValidationSchema must be a valid object");
    }
  };
  this.validateField = function(fieldId, value, values) {
    var field = hasFieldIdArrayValidator(fieldId, _this.fieldSchema) ? formatFieldForArrayField(fieldId, value) : { id: fieldId, value };
    return validateField(field.id, field.value, values, _this.fieldSchema).then(function(internalValidationResult) {
      var validationResult = mapInternalValidationResultToValidationResult(internalValidationResult);
      return fieldId !== field.id ? get_1(validationResult, fieldId) : validationResult;
    });
  };
  this.validateRecord = function(values) {
    return validateRecord(values, _this.recordSchema);
  };
  this.validateForm = function(values) {
    return validateForm(values, _this.fieldSchema, _this.recordSchema).then(mapInternalFormValidationResultToFormValidationResult);
  };
  this.updateValidationSchema = function(validationSchema2) {
    _this.setupValidationSchema(validationSchema2);
  };
  this.setupValidationSchema(validationSchema);
};
var createFormValidation = function createFormValidation2(validationSchema) {
  return new FormValidation(validationSchema);
};
var getArgsToParse = function getArgsToParse2(message) {
  return message.match(/{{[^{}][\w\.]*}}/g);
};
var getArgPath = function getArgPath2(arg) {
  return arg.replace(/[{}]/g, "");
};
var parseMessage = function parseMessage2(message, customArgs) {
  var parsableArgs = getArgsToParse(message);
  return Array.isArray(parsableArgs) ? parsableArgs.reduce(function(customMessage, arg) {
    return customMessage.replace(arg, get_1(customArgs, getArgPath(arg), arg));
  }, message) : message;
};
var parseMessageWithCustomArgs = function parseMessageWithCustomArgs2(message, customArgs) {
  return message ? parseMessage(message, customArgs) : "";
};
var VALIDATOR_TYPE$4 = "REQUIRED";
var defaultMessage$4 = "Please fill in this mandatory field.";
var setErrorMessage$4 = function setErrorMessage(message) {
  return defaultMessage$4 = message;
};
var DEFAULT_PARAMS$3 = { trim: true };
var isStringValid = function isStringValid2(value, trim) {
  return trim ? value.trim().length > 0 : value.length > 0;
};
var isNonStringValid = function isNonStringValid2(value) {
  return value !== void 0 && value !== null;
};
var isValidField$1 = function isValidField(value, trim) {
  return typeof value === "string" ? isStringValid(value, trim) : isNonStringValid(value);
};
var validator$5 = function validator(fieldValidatorArgs) {
  var value = fieldValidatorArgs.value, _fieldValidatorArgs$c = fieldValidatorArgs.customArgs, customArgs = _fieldValidatorArgs$c === void 0 ? DEFAULT_PARAMS$3 : _fieldValidatorArgs$c, _fieldValidatorArgs$m = fieldValidatorArgs.message, message = _fieldValidatorArgs$m === void 0 ? defaultMessage$4 : _fieldValidatorArgs$m;
  var succeeded = isValidField$1(value, Boolean(customArgs.trim));
  return {
    succeeded,
    message: succeeded ? "" : parseMessageWithCustomArgs(message, customArgs),
    type: VALIDATOR_TYPE$4
  };
};
var required = Object.freeze({
  __proto__: null,
  setErrorMessage: setErrorMessage$4,
  validator: validator$5
});
var isEmptyValue = function isEmptyValue2(value) {
  return value === null || value === void 0 || value === "";
};
var isValidPattern = function isValidPattern2(value, pattern2) {
  return isEmptyValue(value) ? true : pattern2.test(value);
};
var VALIDATOR_TYPE$3 = "EMAIL";
var defaultMessage$3 = "Please enter a valid email address.";
var setErrorMessage$3 = function setErrorMessage2(message) {
  return defaultMessage$3 = message;
};
var EMAIL_PATTERN = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var isValidField2 = function isValidField3(value) {
  return isValidPattern(value, EMAIL_PATTERN);
};
var validator$4 = function validator2(fieldValidatorArgs) {
  var value = fieldValidatorArgs.value, _fieldValidatorArgs$m = fieldValidatorArgs.message, message = _fieldValidatorArgs$m === void 0 ? defaultMessage$3 : _fieldValidatorArgs$m;
  var succeeded = isValidField2(value);
  return {
    succeeded,
    message: succeeded ? "" : message,
    type: VALIDATOR_TYPE$3
  };
};
var email = Object.freeze({
  __proto__: null,
  setErrorMessage: setErrorMessage$3,
  validator: validator$4
});
var VALIDATOR_TYPE$2 = "PATTERN";
var defaultMessage$2 = "Please provide a valid format.";
var setErrorMessage$2 = function setErrorMessage3(message) {
  return defaultMessage$2 = message;
};
var BAD_PARAMETER$2 = "FieldValidationError: pattern option for pattern validation is mandatory. Example: { pattern: /d+/ }.";
var DEFAULT_PARAMS$2 = null;
function getRegExp(pattern2) {
  return pattern2 instanceof RegExp ? pattern2 : new RegExp(pattern2);
}
function parsePattern(_ref) {
  var pattern2 = _ref.pattern;
  if (typeof pattern2 === "boolean" || pattern2 === null) {
    throw new Error(BAD_PARAMETER$2);
  }
  return getRegExp(pattern2);
}
var validator$3 = function validator3(fieldValidatorArgs) {
  if (!fieldValidatorArgs.customArgs) {
    throw new Error(BAD_PARAMETER$2);
  }
  var value = fieldValidatorArgs.value, _fieldValidatorArgs$c = fieldValidatorArgs.customArgs, customArgs = _fieldValidatorArgs$c === void 0 ? DEFAULT_PARAMS$2 : _fieldValidatorArgs$c, _fieldValidatorArgs$m = fieldValidatorArgs.message, message = _fieldValidatorArgs$m === void 0 ? defaultMessage$2 : _fieldValidatorArgs$m;
  var pattern2 = parsePattern(customArgs);
  var succeeded = isValidPattern(value, pattern2);
  return {
    succeeded,
    message: succeeded ? "" : parseMessageWithCustomArgs(message, customArgs),
    type: VALIDATOR_TYPE$2
  };
};
var pattern = Object.freeze({
  __proto__: null,
  setErrorMessage: setErrorMessage$2,
  validator: validator$3
});
function parseLengthParams(customParams, errorMessage) {
  var length = customParams.length === null ? NaN : Number(customParams.length);
  if (isNaN(length)) {
    throw new Error(errorMessage);
  }
  return length;
}
function isLengthValid(value, length, validatorFn) {
  return typeof value === "string" ? validatorFn(value, length) : true;
}
var VALIDATOR_TYPE$1 = "MIN_LENGTH";
var defaultMessage$1 = "The value provided does not fulfill min length.";
var setErrorMessage$1 = function setErrorMessage4(message) {
  return defaultMessage$1 = message;
};
var BAD_PARAMETER$1 = 'FieldValidationError: Parameter "length" for minLength in customArgs is mandatory and should be a valid number. Example: { length: 4 }.';
var DEFAULT_PARAMS$1 = null;
var isStringLengthValid$1 = function isStringLengthValid(value, length) {
  return value.length >= length;
};
var validator$2 = function validator4(fieldValidatorArgs) {
  if (!fieldValidatorArgs.customArgs) {
    throw new Error(BAD_PARAMETER$1);
  }
  var value = fieldValidatorArgs.value, _fieldValidatorArgs$c = fieldValidatorArgs.customArgs, customArgs = _fieldValidatorArgs$c === void 0 ? DEFAULT_PARAMS$1 : _fieldValidatorArgs$c, _fieldValidatorArgs$m = fieldValidatorArgs.message, message = _fieldValidatorArgs$m === void 0 ? defaultMessage$1 : _fieldValidatorArgs$m;
  var length = parseLengthParams(customArgs, BAD_PARAMETER$1);
  var succeeded = isLengthValid(value, length, isStringLengthValid$1);
  return {
    succeeded,
    message: succeeded ? "" : parseMessageWithCustomArgs(message, customArgs),
    type: VALIDATOR_TYPE$1
  };
};
var minLength = Object.freeze({
  __proto__: null,
  setErrorMessage: setErrorMessage$1,
  validator: validator$2
});
var VALIDATOR_TYPE = "MAX_LENGTH";
var defaultMessage = "The value provided does not fulfill max length.";
var setErrorMessage5 = function setErrorMessage6(message) {
  return defaultMessage = message;
};
var BAD_PARAMETER = 'FieldValidationError: Parameter "length" for maxLength in customArgs is mandatory and should be a valid number. Example: { length: 4 }.';
var DEFAULT_PARAMS = null;
var isStringLengthValid2 = function isStringLengthValid3(value, length) {
  return value.length <= length;
};
var validator$1 = function validator5(fieldValidatorArgs) {
  if (!fieldValidatorArgs.customArgs) {
    throw new Error(BAD_PARAMETER);
  }
  var value = fieldValidatorArgs.value, _fieldValidatorArgs$c = fieldValidatorArgs.customArgs, customArgs = _fieldValidatorArgs$c === void 0 ? DEFAULT_PARAMS : _fieldValidatorArgs$c, _fieldValidatorArgs$m = fieldValidatorArgs.message, message = _fieldValidatorArgs$m === void 0 ? defaultMessage : _fieldValidatorArgs$m;
  var length = parseLengthParams(customArgs, BAD_PARAMETER);
  var succeeded = isLengthValid(value, length, isStringLengthValid2);
  return {
    succeeded,
    message: succeeded ? "" : parseMessageWithCustomArgs(message, customArgs),
    type: VALIDATOR_TYPE
  };
};
var maxLength = Object.freeze({
  __proto__: null,
  setErrorMessage: setErrorMessage5,
  validator: validator$1
});
var createEmptyArrayValidationResult = function createEmptyArrayValidationResult2() {
  return {
    succeeded: true,
    arrayErrors: []
  };
};
var validator6 = function validator7(validatorArgs) {
  var value = validatorArgs.value, customArgs = validatorArgs.customArgs;
  var formValidation = createFormValidation(customArgs);
  return reduceAsync(
    value,
    function(validationResult, item) {
      return formValidation.validateForm(item).then(function(_ref) {
        var fieldErrors = _ref.fieldErrors, succeeded = _ref.succeeded;
        return {
          succeeded: validationResult.succeeded && succeeded,
          arrayErrors: [].concat(_toConsumableArray(validationResult.arrayErrors), [fieldErrors])
        };
      });
    },
    createEmptyArrayValidationResult()
  ).then(function(arrayValidationResult) {
    return {
      succeeded: arrayValidationResult.succeeded,
      type: "ARRAY_VALIDATIONS",
      message: null,
      arrayErrors: arrayValidationResult.arrayErrors
    };
  });
};
var array = Object.freeze({
  __proto__: null,
  validator: validator6
});
var index = { required, email, pattern, minLength, maxLength, array };

export {
  createDefaultValidationResult,
  createDefaultRecordValidationResult,
  createDefaultFormValidationResult,
  FormValidation,
  createFormValidation,
  parseMessageWithCustomArgs,
  index
};
/*! Bundled license information:

@lemoncode/fonk/dist/@lemoncode/fonk.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=chunk-3WAUHBY2.js.map
